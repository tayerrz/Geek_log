<p>你好，我是朱涛。</p><p>在<a href="https://time.geekbang.org/column/article/472129">开篇词</a>当中，我曾经说过，学好Kotlin的关键在于<strong>思维的转变</strong>。在上一次<a href="https://time.geekbang.org/column/article/478106">加餐课程</a>当中，我给你介绍了Kotlin的函数式编程思想，相信你对Kotlin的“函数思维”已经有了一定的体会。那么今天这节课，我们就来聊聊Kotlin的<strong>表达式思维</strong>。</p><p>所谓编程思维，其实是一种非常抽象的概念，很多时候是只可意会不可言传的。不过，从某种程度上看，学习编程思维，比学习编程语法还要重要。因为<strong>编程思维决定着我们的代码整体的架构与风格</strong>，而具体的某个语法反而没那么大的影响力。当然，如果对Kotlin的语法没有一个全面的认识，编程思维也只会是空中楼阁。</p><p>所以，准确地来说，掌握Kotlin的编程思维，是在掌握了Kotlin语法基础上的一次升华。这就好比是，我们学会了基础的汉字以后开始写作文一样。学了汉字以后，如果不懂得写作的技巧，是写不出优美的文章的。同理，如果学了Kotlin语法，却没有掌握它的编程思维，也是写不出优雅的Kotlin代码的。</p><p>好，那么接下来，我们就来看看Kotlin的表达式思维。</p><h2>表达式思维</h2><p>在正式开始学习表达式思维之前，我们先来看一段简单的Kotlin代码。</p><pre><code class="language-plain">var i = 0
if (data != null) {
    i = data
}

var j = 0
if (data != null) {
    j = data
} else {
    j = getDefault()
    println(j)
}

var k = 0
if (data != null) {
    k = data
} else {
    throw NullPointerException()
}

var x = 0
when (data) {
    is Int -&gt; x = data
    else -&gt; x = 0
}

var y = 0
try {
    y = "Kotlin".toInt()
} catch (e: NumberFormatException) {
    println(e)
    y = 0
}
</code></pre><!-- [[[read_end]]] --><p>这些代码，如果我们用Java的思维来分析的话，是挑不出太多毛病的。但是站在Kotlin的角度，就完全不一样了。</p><p>利用Kotlin的语法，我们完全可以将代码写得更加简洁，就像下面这样：</p><pre><code class="language-plain">val i = data ?: 0
val j = data ?: getDefault().also { println(it) }

val k = data?: throw NullPointerException()



val x = when (data) {
    is Int -&gt; data
    else -&gt; 0
}

val y = try {
    "Kotlin".toInt()
} catch (e: NumberFormatException) {
    println(e)
    0
}
</code></pre><p>这段代码看起来就简洁了不少，但如果你有Java经验，你在写代码的时候，脑子里第一时间想到的一定不是这样的代码模式。这个，也是我们需要格外注意培养表达式思维的原因。</p><p>不过，现在你心里可能已经出现了一个疑问：<strong>Kotlin凭什么就能用这样的方式写代码呢？<strong>其实这是因为：if、when、throw、try-catch这些语法，在Kotlin当中都是</strong>表达式</strong>。</p><p>那么，这个“表达式”到底是什么呢？其实，与<a href="https://kotlinlang.org/spec/expressions.html#expressions">表达式</a>（Expression）对应的，还有另一个概念，我们叫做<a href="https://kotlinlang.org/spec/statements.html#statements">语句</a>（Statement）。这两者的准确定义其实很复杂，你可以点击我这里给出的链接去看看它们之间区别。</p><p>不过我们可以先简单来概括一下：<strong>表达式，是一段可以产生值的代码；而语句，则是一句不产生值的代码。</strong>这样解释还是有些抽象，我们来看一些例子：</p><pre><code class="language-plain">val a = 1    // statement
println(a)   // statement

// statement
var i = 0
if (data != null) {
    i = data
}

// 1 + 2 是一个表达式，但是对b的赋值行为是statement
val b = 1 + 2

// if else 整体是一个表达式
// a &gt; b是一个表达式
// a - b是一个表达式
// b - a是一个表达式。
fun minus(a: Int, b: Int) = if (a &gt; b) a - b else b - a

// throw NotImplementedError() 是一个表达式
fun calculate(): Int = throw NotImplementedError()
</code></pre><p>这段代码是描述了常见的Kotlin代码模式，从它的注释当中，我们其实可以总结出这样几个规律：</p><ul>
<li>赋值语句，就是典型的statement；</li>
<li>if语法，既可以作为语句，也可以作为表达式；</li>
<li>语句与表达式，它们可能会出现在同一行代码中，比如val b = 1 + 2；</li>
<li>表达式还可能包含“子表达式”，就比如这里的minus方法；</li>
<li>throw语句，也可以作为表达式。</li>
</ul><p>但是看到这里，你的心中应该还是有一个疑问没有解开，那就是：<strong>calculate()这个函数难道不会引起编译器报错吗？</strong></p><pre><code class="language-plain">//       函数返回值类型是Int，实际上却抛出了异常，没有返回Int
//                ↓       ↓
fun calculate(): Int = throw NotImplementedError()
</code></pre><p>确实，在刚开始接触Kotlin的时候，我也无法理解这样的代码。直到我弄清楚Kotlin整个类型系统以后，我才真正找到答案。</p><p>所以，为了让你能真正理解Kotlin表达式背后的原理，接下来，我们就来系统学习一下Kotlin的类型系统吧。</p><h2>类型系统</h2><p>在课程的<a href="https://time.geekbang.org/column/article/472154">第1讲</a>我们就学过，在Kotlin当中，Any是所有类型的父类，我们可以称之为<strong>根类型</strong>。同时，我们也学过，Kotlin的类型还分为<strong>可空类型</strong>和<strong>不可空类型</strong>。举个例子，对于字符串类型，就有String、String?，它们两者分别代表了不为空的字符串、可能为空的字符串。</p><p>在这个基础上，我们很容易就能推测出，Kotlin的类型体系应该是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/18/40/1873d04968cd8aca90381b9f84651f40.jpg?wh=2000x979" alt=""></p><p>也就是，Any是所有非空类型的根类型；而Any?是所有可空类型的根类型。那么现在，你可能会想到这样的一个问题：<strong>Any与Any?之间是什么关系呢？</strong></p><h3>Any与Any?与Object</h3><p>从表面上看，这两个确实没有继承关系。不过，它们之间其实是存在一些微妙的联系的。</p><p>在Kotlin当中，我们可以把“子类型”赋值给“父类型”，就像下面的代码一样：</p><pre><code class="language-plain">val s: String = ""
val any: Any = s
</code></pre><p>由于String是Any的子类型，因此，我们可以将String类型赋值给Any类型。而实际上，Any和“Any?”之间也是类似的，我们可以将Any类型赋值给“Any？”类型，反之则不行。</p><pre><code class="language-plain">val a: Any = ""
val b: Any? = a // 通过

val c: Any = b  // 报错
</code></pre><p>类似的，String类型可以赋值给“String？”类型，反之也不行。你可能会想这是为什么呢？<br>
其实，<strong>任何类型，当它被“?”修饰，变成可空类型以后，它就变成原本类型的父类了。<strong>所以，从某种程度上讲，我们可以认为“Any？”是所有Kotlin类型的</strong>根类型</strong>。它的具体关系如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/d9/dd/d904d1ed5df67211058yya5098868cdd.jpg?wh=2000x1044" alt=""></p><p>因此，我们可以说：虽然Any与Any？之间没有继承的关系，但是我们可以将Any看作是Any？的子类；String类型可以看作是String？的子类。</p><p>而由于Any与“Any？”之间并没有明确的继承关系，但它们又存在父子类型的关系，所以在上面的示意图中，我们用虚线来表示。</p><p>所以到这里，我们就弄明白了一个问题：<strong>Kotlin的Any与Java的Object之间是什么关系？</strong></p><p>那么，答案也是显而易见的，Java当中的Object类型，对应Kotlin的“Any？”类型。但两者并<strong>不完全等价</strong>，因为Kotlin的Any可以没有wait()、notify()之类的方法。因此，我们只能说Kotlin的“Any？”与Java的Object是大致对应的。Intellij有一个功能，可以将Java代码转换成Kotlin代码，我们可以借此印证。</p><p>这是一段Java代码，它有三个方法，分别是可为空的Object类型、不可为空的Object类型，以及无注解的Object类型。</p><pre><code class="language-java">public class TestType {

    @Nullable  // 可空注解
    public Object test() { return null; }

    public Object test1() { return null; }

    @NotNull  // 不可空注解
    public Object test2() { return 1; }
}
</code></pre><p>上面的代码转换成Kotlin以后，会变成这样：</p><pre><code class="language-plain">class TestType {
    fun test(): Any? { return null }

    fun test1(): Any? { return null }

    fun test2(): Any { return 1 }
}
</code></pre><p>由此可见，在没有注解标明可空信息的时候，Object类型是会被当作“Any？”来看待的。而在有了注解修饰以后，Kotlin就能够识别出到底是Any，还是“Any？”。</p><h3>Unit与Void与void</h3><p>在Kotlin当中，除了普通的Any、String的类型之外，还有一个特殊的类型，叫做<strong>Unit</strong>。而Unit这个类型，经常会被拿来和Java的Void、void来对比。</p><p>那么在这里，你首先需要知道的是：在Java当中，Void和void不是一回事（注意大小写），前者是一个Java的类，后者是一个用于修饰方法的关键字。如下所示：</p><pre><code class="language-plain">public final class Void {

    public static final Class&lt;Void&gt; TYPE = (Class&lt;Void&gt;) Class.getPrimitiveClass("void");

    private Void() {}
}
</code></pre><p>从语法含义上来讲，Kotlin的Unit与Java的void更加接近，但Unit远不止于此。在Kotlin当中，Unit也是一个类，这点跟Void又有点像。比如，在下面的代码中，Unit是一个类型的同时，还是一个单例：</p><pre><code class="language-plain">public object Unit {
    override fun toString() = "kotlin.Unit"
}
</code></pre><p>所以，我们就可以用Unit写出很灵活的代码。就像下面这样：</p><pre><code class="language-plain">fun funUnit(): Unit { }

fun funUnit1(): Unit { return Unit }
</code></pre><p>可以看到，当返回值类型是Unit的时候，我们既可以选择不写return，也可以选择return一个Unit的单例对象。</p><p>另外，在使用泛型编程的时候，当T类型作为返回值类型的时候，我们传入Unit以后，就不再需要写return了。</p><pre><code class="language-plain">interface Task&lt;T&gt; {
    fun excute(any: Any): T
}

class PrintTask: Task&lt;Unit&gt; {
    override fun excute(any: Any) {
        println(any)
        // 这里写不写return都可以
    }
}
</code></pre><p>更重要的是，Unit还有助于我们实现函数类型。</p><pre><code class="language-plain">val f: () -&gt; Unit = {}
</code></pre><p>所以，Kotlin的Unit与Java的Void或者void并不存在等价的关系，但它们之间确实存在一些概念上的相似性。至此，我们也可以更新一下前面那个类型系统关系图了：</p><p><img src="https://static001.geekbang.org/resource/image/74/7f/74e9ea7a804e30bc0e49982ce12f547f.jpg?wh=2000x1036" alt=""></p><p>可见，Unit其实和String类型一样，就是一个普通的类。只是因为Kotlin编译器会特殊对待它，当Unit作为返回值类型的时候，可以不需要return。</p><p>好了，接着，我们再来看看Kotlin当中经常被提到的Nothing类型。</p><h3>Nothing</h3><p>在有了前面的基础以后呢，Nothing就很容易理解了。其实，<strong>Nothing就是Kotlin所有类型的子类型</strong>。</p><p>Nothing的概念与“Any?”恰好相反。“Any?”是所有的Kotlin类型的父类，Nothing则是所有类型的子类。如果用一张图来概括，大概会是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/35/3a/35dd00d1acyyd43b7b72dc4cf84d3c3a.jpg?wh=2000x1125" alt=""></p><p>事实上，像Nothing这样的概念，在函数式编程当中，也被叫做<strong>底类型</strong>（Bottom Type），因为它位于整个类型体系的最底部。</p><p>而了解了Kotlin的Nothing类型以后，我们其实就可以尝试着来解答前面例子中留下来的疑问了：</p><pre><code class="language-plain">//       函数返回值类型是Int，实际上却抛出了异常，没有返回Int
//                ↓       ↓
fun calculate(): Int = throw NotImplementedError() // 不会报错

//       函数返回值类型是Any，实际上却抛出了异常，没有返回Any
//                ↓       ↓
fun calculate1(): Any = throw Exception() // 不会报错

//       函数返回值类型是Unit，实际上却抛出了异常，没有返回Unit
//                 ↓       ↓
fun calculate2(): Unit = throw Exception() // 不会报错
</code></pre><p>根据这段代码可以发现，不管函数的返回值类型是什么，我们都可以使用抛出异常的方式来实现它的功能。这样我们其实就可以推测出一个结论：<strong>throw这个表达式的返回值是Nothing类型。</strong>而既然Nothing是所有类型的子类型，那么它当然是可以赋值给任意其他类型的。</p><p>可是，我们如何才能印证这个结论是否正确呢？很简单，我们可以把两个函数的返回值类型都改成Nothing，然后看看编译器会不会报错：</p><pre><code class="language-plain">// 不会报错
fun calculate(): Nothing = throw NotImplementedError() 

// 不会报错
fun calculate1(): Nothing = throw Exception() 

// Nothing构造函数是私有的，因此我们无法构造它的实例
public class Nothing private constructor()
</code></pre><p>可见，编译器仍然不会报错。这也就印证了我们前面的猜测：throw表达式的返回值类型是Nothing。</p><p>另外，我们应该也注意到了Nothing类的构造函数是私有的，因此我们无法构造出它的实例。而当Nothing类型作为函数参数的时候，一个有趣的现象就出现了：</p><pre><code class="language-plain">// 这是一个无法调用的函数，因为找不到合适的参数
fun show(msg: Nothing) {
}

show(null) // 报错
show(throw Exception()) // 虽然不报错，但方法仍然不会调用
</code></pre><p>这里我们定义的这个show方法，它的参数类型是Nothing，而由于Nothing的构造函数是私有的，这就导致我们将无法调用show这个函数，除非我们抛出异常，但这没有意义。这个概念在泛型星投影的时候是有应用的，具体你可以点击<a href="https://kotlinlang.org/docs/generics.html#star-projections">这个链接</a>去查看详情。</p><p>而除此之外，Nothing还有助于编译器进行代码流程的推断。比如说，当一个表达式的返回值是Nothing的时候，就往往意味着它后面的语句不再有机会被执行。如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/33/5a/3365f67ab5f828ef23af65484d317a5a.png?wh=676x371" alt="图片"></p><p>在了解了Unit与Nothing这两个不可空的类型以后，我们再来看看它们对应的可空类型。</p><h3>Unit?与Nothing?</h3><p>也许你也注意到了，Unit对应的还有一个“Unit?”类型，那么这个类型有什么意义吗？</p><p>我们可以看看下面的代码：</p><pre><code class="language-plain">fun f1(): Unit? { return null } // 通过

fun f2(): Unit? { return Unit } // 通过

fun f3(): Unit? { throw Exception() } // 通过

fun f4(): Unit? { } // 报错，缺少return
</code></pre><p>可见，Kotlin编译器只会把Unit类型当作无需返回值的类型，而Unit?则不行。</p><p>所以，Unit?这个类型其实没有什么广泛的应用场景，因为它失去了原本的编译器特权后，就只能有3种实现方式，即null、Unit单例、Nothing。也就是说，当Unit?作为返回值的时候，我们的函数必须要return一个值了，它返回值的类型可以是null、Unit单例、Nothing这三种情况。</p><p>好，接下来我们再来看看“Nothing?”这个类型。</p><pre><code class="language-plain">fun calculate1(): Nothing? = null
fun calculate2(): Nothing? = throw Exception()
</code></pre><p>由以上代码示例可知，当Nothing?作为返回值类型的时候，我们可以返回null，或者是抛出异常。这一切都符合预期，而当它作为函数参数的时候，也会有一些有趣的变化。</p><pre><code class="language-plain">//               变化在这里
//                   ↓
fun show(msg: Nothing?) {
}

show(null) // 通过
show(throw Exception()) // 虽然不报错，但方法仍然不会调用
</code></pre><p>可以看到，当参数类型是Nothing?的时候，我们的函数仍然是可以调用的。这其实就能进一步说明一个问题：<strong>Nothing才是底类型，而“Nothing?”则不是底类型。</strong><br>
这一点其实在前面的类型关系图中就有体现，现在你就可以真正理解了：</p><p><img src="https://static001.geekbang.org/resource/image/35/3a/35dd00d1acyyd43b7b72dc4cf84d3c3a.jpg?wh=2000x1125" alt=""></p><p>到这里相信你也明白了，“Unit?”“Nothing?”这两个类型，其实并没有太多实际的应用场景，不过由于它们是Kotlin类型系统当中特殊的类型，因此我们也应该对它们有个清晰的认识。</p><p>这样，在系统学习了Kotlin的类型系统以后，我们对表达式理解就可以更上一层楼了。</p><h2>表达式的本质</h2><p>我们再来看看表达式的定义：<strong>表达式，是一段可以产生值的代码；而语句，则是一句不产生值的代码。</strong></p><p>也许你听说过这样一句话：在Kotlin当中，一切都是表达式。<strong>注意！这句话其实是错的。</strong>因为Kotlin当中还是存在语句的，比如while循环、for循环，等等。</p><p>不过，如果我们换个说法：<strong>在Kotlin当中，大部分代码都是表达式。</strong>这句话就对了。Kotlin的类型系统当中的Unit和Nothing，让很多原本无法产生返回值的语句，变成了表达式。</p><p>我们来举个例子：</p><pre><code class="language-plain">// statement
println("Hello World.")

// println("Hello World.") 变成了表达式
val a = println("Hello World.")

// statement
throw Exception()

// throw 变成了表达式
fun test1() = throw Exception() 
</code></pre><p>从上面的代码案例中，我们可以总结出两个规律。</p><ul>
<li>由于Kotlin存在Unit这个类型，因此println(“Hello World.”)这行代码也可以变成表达式，它所产生的值就是Unit这个单例。</li>
<li>由于Kotlin存在Nothing这个类型，因此throw也可以作为表达式，它所产生的值就是Nothing类型。</li>
</ul><p>注意，因为Java当中不存在Unit、Nothing这样的类型，所以Java里返回值为void的函数是无法成为表达式的，另外，throw这样的语句也是无法成为表达式的。而也正是因为Kotlin这样的类型系统，才让大部分的语句都摇身一变成为了表达式。因为Unit、Nothing在Kotlin编译器看来，也是所有类型当中的一种。</p><p>可以说，Unit和Nothing填补了原本Java当中的类型系统，让Kotlin的类型系统更加全面。也正因为如此，Kotlin才可以拥有真正的函数类型，比如：</p><pre><code class="language-plain">val f: (String) -&gt; Unit = ::println
</code></pre><p>可以看到，如果不存在Unit这个类型，我们是无法描述println这个函数的类型的。正因为println函数的返回值类型为Unit，我们才可以用“(String) -&gt; Unit”来描述它。</p><p>换句话说就是：<strong>Kotlin的类型系统让大部分的语句都变成了表达式，同时也让无返回值的函数有了类型。</strong></p><p>而所谓的表达式思维，其实就是要求我们开发者在编程的时候，<strong>时刻记住Kotlin大部分的语句都是可以作为表达式的</strong>，并且由于表达式都是有返回值的，这也就让我们可以用一种全新的思维来写代码。这在很多时候，都可以大大简化我们的代码逻辑。</p><p>那么现在，我们再回过头看之前的代码，就会觉得很顺眼了：</p><pre><code class="language-plain">val i = data ?: 0
val j = data ?: getDefault().also { println(it) }

val k = data?: throw NullPointerException()


val x = when (data) {
    is Int -&gt; data
    else -&gt; 0
}

val y = try {
    "Kotlin".toInt()
} catch (e: NumberFormatException) {
    0
}
</code></pre><h2>小结</h2><p>好，今天这节加餐，到这里就接近尾声了，我们来做个简单的总结。</p><ul>
<li>所谓的<strong>表达式思维</strong>，就是要时刻记住：Kotlin大部分的语句都是表达式，它是可以产生返回值的。利用这种思维，往往可以大大简化代码逻辑。</li>
<li>Any是所有非空类型的根类型，而“Any?”才是所有类型的<strong>根类型</strong>。</li>
<li>Unit与Java的void类型，代表一个函数不需要返回值；而“Unit?”这个类型则没有太多实际的意义。</li>
<li>当Nothing作为函数返回值的时候，意味着这个函数永远不会返回结果，而且还会截断程序的后续流程。Kotlin编译器也会根据这一点，进行流程分析。</li>
<li>当Nothing作为函数参数的时候，就意味着这个函数永远无法被正常调用。这在泛型星投影的时候是有一定应用的。</li>
<li>另外，Nothing可以看作是“Nothing?”子类型，因此，Nothing可以看作是Kotlin所有类型的<strong>底类型</strong>。</li>
<li>正是因为Kotlin在类型系统当中，加入了Unit、Nothing这两个类型，才让大部分无法产生值的语句摇身一变，成为了表达式。这也是“Kotlin大部分的语句都是表达式”的根本原因。</li>
</ul><h2>思考题</h2><p>这节课，我们学习了表达式思维，请问，你觉得它和我们前面学到的“函数式编程”有联系吗？为什么？欢迎在留言区分享你的答案和思考，也欢迎你把今天的内容分享给更多的朋友。</p>